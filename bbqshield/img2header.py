#!/usr/bin/env python3

import sys, os, re
from argparse import ArgumentParser
from io import StringIO
from textwrap import dedent
from types import SimpleNamespace
from PIL import Image

def normalize_name(name):
    name = re.sub(r'\.h$', '', name)
    name = name.upper()
    name = re.sub('[^A-Z_]', '_', name)
    name = re.sub('_+', '_', name)
    return name

def get_image_data(imgfile, first_row):
    with Image.open(imgfile) as img:
        out = SimpleNamespace()
        out.width = img.width
        data = list(img.getdata())
        if len(data[0]) > 3:
            data = [d[:3] for d in data]
        if first_row:
            out.height = 1
            out.data = data[:out.width]
        else:
            out.height = img.height
            out.data = data
        return out

def format_array_data(data):
    with StringIO() as out:
        for i, d in enumerate(data.data):
            if data.height == 1 or i % data.width == 0:
                out.write('   ')
            out.write(' { .i = 0x%06x },'%(
                ((d[0] & 0xff) << 16) | ((d[1] & 0xff) << 8) | (d[2] & 0xff)))
            if data.height == 1 or i % data.width == (data.width - 1):
                out.write('\n')
        return out.getvalue()

def emit_image_header(outfile, name, d):
    s = """\
        #define {0}_WIDTH {1}
        #define {0}_HEIGHT {2}
        static const Color {3}_data[{0}_WIDTH * {0}_HEIGHT] = """
    # closing brace on its own line to avoid confusing .format() and vim
    outfile.write(dedent(s.format(name, d.width, d.height, name.lower())) + "{\n")
    outfile.write(format_array_data(d))
    outfile.write('};\n')

def emit_file_header(outfile, name):
    outfile.write(dedent("""\
            /* this file was autogenerated by img2header.py */
            #ifndef {0}_H
            #define {0}_H\n
            #include "Color.h"\n
            """.format(name)))

def do_single_image(name, imgfile, outfile, gradient):
    d = get_image_data(imgfile, gradient)
    emit_file_header(outfile, name)
    emit_image_header(outfile, name, d)
    outfile.write('\n#endif\n')

def do_animation(name, imgfiles, outfile, use_pallette=False):
    frames = [get_image_data(f, False) for f in imgfiles]
    if len({f.width for f in frames}) > 1 or len({f.height for f in frames}) > 1:
        raise ValueError('Frames are not all the same size')
    width = frames[0].width
    height = frames[0].height

    emit_file_header(outfile, name)
    outfile.write('#define %s_WIDTH %d\n'%(name, width))
    outfile.write('#define %s_HEIGHT %d\n'%(name, height))
    outfile.write('#define %s_NFRAMES %d\n'%(name, len(frames)))
    if use_pallette:
        pallette = sorted(list(set(sum([f.data for f in frames], []))), key=sum)
        outfile.write('static const Color %s_pallette[%d] = {\n'%(name.lower(), len(pallette)))
        for p in pallette:
            outfile.write('    { .i = 0x%06x },\n'%(((p[0] & 0xff) << 16) | ((p[1] & 0xff) << 8) | (p[2] & 0xff)))
        outfile.write('};\n\n')

        outfile.write('static const uint8_t {0}_pdata[{1}_WIDTH * {1}_HEIGHT * {1}_NFRAMES] = '.format(name.lower(), name) + '{\n')
        for j, frame in enumerate(frames):
            for i, d in enumerate(frame.data):
                if i % width == 0:
                    outfile.write('  ')
                outfile.write(' % 2d,'%pallette.index(d))
                if i % width == (width-1):
                    outfile.write('\n')
            if j != len(frames)-1:
                outfile.write('\n')

    else:
        outfile.write('static const Color {0}_data[{1}_WIDTH * {1}_HEIGHT * {1}_NFRAMES] = '.format(name.lower(), name) + '{\n')
        for i, f in enumerate(frames):
            outfile.write(format_array_data(f))
            if i != len(frames)-1:
                outfile.write('\n')

    outfile.write('};\n\n#endif\n')

if __name__ == '__main__':
    parser = ArgumentParser()
    parser.add_argument('-o', '--output', default='-', help='output file (- for stdin)')
    parser.add_argument('-g', '--gradient', action='store_true', help='gradient mode (return only first row)')
    parser.add_argument('-p', '--pallette', action='store_true', help='pallette mode for animations')
    parser.add_argument('images', metavar='IMAGE', nargs='+', help='image input files')
    args = parser.parse_args()

    if args.output == '-':
        outfile = sys.stdout
        name = 'IMAGE'
    else:
        outfile = open(args.output, 'w')
        name = normalize_name(args.output)

    if len(args.images) == 1:
        do_single_image(name, args.images[0], outfile, args.gradient)
    else:
        do_animation(name, args.images, outfile, args.pallette)
